#!/usr/bin/env python3
import argparse
import os
import colorsys
from colorspace import swatchplot, palette, hexcols

def hex_to_rgb(hex_color):
    """
    Convert a hex color string (e.g. "#FDF5E6") to a tuple of normalized RGB values.
    """
    hex_color = hex_color.lstrip('#')
    r = int(hex_color[0:2], 16) / 255.0
    g = int(hex_color[2:4], 16) / 255.0
    b = int(hex_color[4:6], 16) / 255.0
    return r, g, b

def rgb_to_hex(r, g, b):
    """
    Convert normalized RGB values to a hex color string.
    """
    return '#{:02X}{:02X}{:02X}'.format(
        int(round(r * 255)),
        int(round(g * 255)),
        int(round(b * 255))
    )

def generate_palette(original_hex, n):
    """
    For a given original hex colour and palette size n, generate a list of n colours.
    
    Each colour is generated by varying the lightness from 0.05 to 0.95 while keeping the 
    hue and saturation the same as the original. The colour from the original lightness is 
    ensured to appear in the list.
    
    Returns a list of tuples: (hex_color, is_base) where is_base is True for the original colour.
    """
    # Convert the original hex color to normalized RGB then to HLS (colorsys uses HLS)
    r, g, b = hex_to_rgb(original_hex)
    h, l, s = colorsys.rgb_to_hls(r, g, b)
    
    # Special case: if n is 1, return only the original colour.
    if n == 1:
        return [(original_hex.upper(), True)]
    
    # Generate n evenly spaced lightness values between 0.05 and 0.95
    lightness_values = [0.05 + i * (0.95 - 0.05) / (n - 1) for i in range(n)]
    
    # Find the index where the generated lightness is closest to the original colour's lightness
    differences = [abs(lv - l) for lv in lightness_values]
    base_index = differences.index(min(differences))
    
    # Ensure that the original lightness is used in the palette so the base colour is exact
    lightness_values[base_index] = l

    palette = []
    for lv in lightness_values:
        # For the base lightness, use the original hex (ensuring an exact match)
        if lv == l:
            palette.append((original_hex.upper(), True))
        else:
            # Convert HLS (with modified lightness) back to RGB and then to hex
            r_new, g_new, b_new = colorsys.hls_to_rgb(h, lv, s)
            palette.append((rgb_to_hex(r_new, g_new, b_new), False))
    return palette

def generate_css(palettes):
    """
    Generate CSS content given a list of palettes.
    
    Each palette in the list corresponds to one base colour (with its variations).
    The CSS variables are named as --colorX-Y where X is the palette index (starting at 1) 
    and Y is a percentage label computed by evenly spacing numbers from 10 to 80 (if n=8, for example).
    
    The original (base) colour gets an extra comment: /* Base color */
    """
    css_lines = [":root {"]
    
    for idx, palette in enumerate(palettes, start=1):
        n = len(palette)
        for j, (hex_color, is_base) in enumerate(palette):
            # Compute a percentage label for the CSS variable name.
            # Here we linearly interpolate between 10 and 80.
            if n > 1:
                perc = int(round(10 + j * (80 - 10) / (n - 1)))
            else:
                perc = 40  # fallback value for n==1
            line = f"\t--color{idx}-{perc}: {hex_color};"
            if is_base:
                line += " /* Base color */"
            css_lines.append(line)
        css_lines.append("")  # Blank line between groups
    css_lines.append("}")
    return "\n".join(css_lines)

def main():
    parser = argparse.ArgumentParser(
        description="Generate a CSS palette file from a list of hex colours."
    )
    parser.add_argument("input", help="Path to the input file containing hex colours")
    parser.add_argument("output", help="Output directory where palette.css will be saved")
    parser.add_argument("num", type=int, help="Number of colours per palette")
    
    args = parser.parse_args()
    
    # Read the input file and store non-empty lines as hex colours
    with open(args.input, "r") as f:
        colors = [line.strip() for line in f if line.strip()]
    
    # Generate a palette (list of (hex, bool)) for each colour in the input
    palettes = [generate_palette(color, args.num) for color in colors]
    palettes_hexs = []

    for palette in palettes:
        one_palette_hexs = [colour[0] for colour in palette]
        palettes_hexs.append(one_palette_hexs)
    
    hexcols_prepared = []

    for hex_list in palettes_hexs:
        hexcols_prepared.append(hexcols(hex_list))

    print(hexcols_prepared)

    # Create CSS content from the generated palettes
    css_content = generate_css(palettes)
    
    # Ensure the output directory exists; then write palette.css in that folder
    output_file = os.path.join(args.output)
    with open(output_file, "w") as f:
        f.write(css_content)
    
    print(f"CSS palette generated at {output_file}")
    
    swatchplot(hexcols_prepared, n = 8, figsize = (8, 1.5))

if __name__ == "__main__":
    main()

